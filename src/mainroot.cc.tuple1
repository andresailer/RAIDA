#include <ROOT_AIDA/utilROOT.h>
#include <TH1F.h>
#include <TDirectory.h>
#include <TFile.h>
#include <TTree.h>


#include <iostream>
#include <string>
#include <vector>

#include <AIDA/IAnalysisFactory.h>
#include <AIDA/ITreeFactory.h>
#include <AIDA/ITree.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/IHistogram1D.h>
#include <AIDA/IHistogram2D.h>
#include <AIDA/IHistogram3D.h>

using namespace AIDA ;
using namespace std;

// ----------------------------------------------------------------------------
class TreePoint {
public:
  TreePoint() {_type = 'D';}
  TreePoint(string type) {_type = type[0];}

  void* getValue() 
  {
    if (_type == 'D') 
      {
	return &_d;
      } 
    else if (_type == 'F')
      {
	return &_f;
      }
    else if (_type == 'I')
      {
	return &_i;
      }
    else if (_type == 'S')
      {
	return &_s;
      }
    else if (_type == 'L')
      {
	return &_l;
      }
    else if (_type == 'O')
      {
	return &_b;
      }
    else if (_type == 'B')
      {
	return &_c;
      }
    else if (_type == 'C')
      {
	return (void*)_st.c_str();
      }
    return &_d;
  }

  bool set(const float v) 
  {
    double temp = v;
    return set(temp);
  }

  bool set(const double v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	if (v > FLT_MAX && v < FLT_MAX)
	  {
	    _f = v;
	    return true;
	  }
	else 
	  {
	    _f = 0;
	    return false;
	  }
      }
    else if (_type == 'I')
      {
	if (v > INT_MIN && v < INT_MAX)
	  {
	    _i = v;
	    return true;
	  }
	else 
	  {
	    _i = 0;
	    return false;
	  }
      }
    else if (_type == 'S')
      {
	if (v > SHRT_MIN && v < SHRT_MAX)
	  {
	    _s = v;
	    return true;
	  }
	else 
	  {
	    _s = 0;
	    return false;
	  }
      }
    else if (_type == 'L')
      {
	if (v > INT_MIN && v < INT_MAX)
	  {
	    _l = v;
	    return true;
	  }
	else 
	  {
	    _l = 0;
	    return false;
	  }
      }
    else if (_type == 'B')
      {
	if (v > SCHAR_MIN && v < SCHAR_MAX)
	  {
	    _c = v;
	    return true;
	  }
	else 
	  {
	    _c = 0;
	    return false;
	  }
      }
    return false;
  }

  bool set(const int v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	_f = v;
	return true;
      }
    else if (_type == 'I')
      {
	_i = v;
	return true;
      }
    else if (_type == 'S')
      {
	if (v > SHRT_MIN && v < SHRT_MAX)
	  {
	    _s = v;
	    return true;
	  }
	else 
	  {
	    _s = 0;
	    return false;
	  }
      }
    else if (_type == 'L')
      {
	_l = v;
	return true;
      }
    else if (_type == 'O')
      {
	if (v) 
	  _b = true;
	else
	  _b = false;
	return true;
      }
    else if (_type == 'B')
      {
	if (v > SCHAR_MIN && v < SCHAR_MAX)
	  {
	    _c = v;
	    return true;
	  }
	else 
	  {
	    _c = 0;
	    return false;
	  }
      }
    return false;
  }

  bool set(const short v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	_f = v;
	return true;
      }
    else if (_type == 'I')
      {
	_i = v;
	return true;
      }
    else if (_type == 'S')
      {
	_s = v;
	return true;
      }
    else if (_type == 'L')
      {
	_l = v;
	return true;
      }
    else if (_type == 'O')
      {
	if (v) 
	  _b = true;
	else
	  _b = false;
	return true;
      }
    else if (_type == 'B')
      {
	if (v > SCHAR_MIN && v < SCHAR_MAX)
	  {
	    _c = v;
	    return true;
	  }
	else 
	  {
	    _c = 0;
	    return false;
	  }
      }
    return false;
  }

  bool set(const long v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	_f = v;
	return true;
      }
    else if (_type == 'I')
      {
	if (v > INT_MIN && v < INT_MAX)
	  {
	    _i = v;
	    return true;
	  }
	else 
	  {
	    _i = 0;
	    return false;
	  }
      }
    else if (_type == 'S')
      {
	if (v > SHRT_MIN && v < SHRT_MAX)
	  {
	    _s = v;
	    return true;
	  }
	else 
	  {
	    _s = 0;
	    return false;
	  }
      }
    else if (_type == 'L')
      {
	_l = v;
	return true;
      }
    else if (_type == 'O')
      {
	if (v) 
	  _b = true;
	else
	  _b = false;
	return true;
      }
    else if (_type == 'B')
      {
	if (v > SCHAR_MIN && v < SCHAR_MAX)
	  {
	    _c = v;
	    return true;
	  }
	else 
	  {
	    _c = 0;
	    return false;
	  }
      }
    return false;
  }

  bool set(const char v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	_f = v;
	return true;
      }
    else if (_type == 'I')
      {
	_i = v;
	return true;
      }
    else if (_type == 'S')
      {
	_s = v;
	return true;
      }
    else if (_type == 'L')
      {
	_l = v;
	return true;
      }
    else if (_type == 'O')
      {
	if (v) 
	  _b = true;
	else
	  _b = false;
	return true;
      }
    else if (_type == 'B')
      {
	_c = v;
	return true;
      }
    return false;
  }

  bool set(const bool v) 
  {
    if (_type == 'D') 
      {
	_d = v;
	return true;
      } 
    else if (_type == 'F')
      {
	_f = v;
	return true;
      }
    else if (_type == 'I')
      {
	_i = v;
	return true;
      }
    else if (_type == 'S')
      {
	_s = v;
	return true;
      }
    else if (_type == 'L')
      {
	_l = v;
	return true;
      }
    else if (_type == 'O')
      {
	_b = v;
	return true;
      }
    else if (_type == 'B')
      {
	_c = v;
	return true;
      }
    return false;
  }

  bool set(const string v) 
  {
    _st = v;
    return true;
  }

private:
  char _type;
  Float_t _f;
  Double_t _d;
  Int_t _i;
  Short_t _s; // Signed Short integer 
  // Long64_t _l;
  Int_t _l; // Long is treated as int because there is no normal long in ROOT
  Char_t _c; 
  Bool_t _b;
  string _st;

};
// ----------------------------------------------------------------------------


int main()
{
  IAnalysisFactory * myaida;
  ITreeFactory * mytreefactory;
  ITree * mytree;
  IHistogramFactory * myhistofactory;
  myaida = AIDA_createAnalysisFactory();
  mytreefactory = myaida->createTreeFactory();


  std::string storeName("aidaroot.root");
  std::string storeType("root");
  bool readOnly = false;
  bool createNew = false;
  std::string options("keine");
  mytree = mytreefactory->create(storeName,storeType,readOnly,createNew,options);

  myhistofactory = myaida->createHistogramFactory(*mytree);


/// Anlegen eines TTrees ------------------------------------------------------
  vector<TreePoint> vp;
  vector<Double_t> vd;
  vector<string> vname, vtype;

  vname.push_back("px");
  vname.push_back("py");
  vname.push_back("pz");
  vtype.push_back("D");
  vtype.push_back("D");
  vtype.push_back("D");

  for (int i = 0;i<3;i++)
    {
      TreePoint *mytp = new TreePoint; 
      vp.push_back(*mytp);
    }
  TTree *ttree = new TTree("mytree","my first ttree obj.");
  for (unsigned i = 0;i<vtype.size();i++)
    {
      string ss;
      ss = vname[i] + "/" + vtype[i];
      ttree->Branch(vname[i].c_str(),vp[i].getValue(),ss.c_str());
    }
  cout << "### ja, ich lebe noch!! ###" << endl;

  vp[0].set(10);
  vp[1].set(20);
  vp[2].set(30);
  ttree->Fill();

  vp[0].set(11);
  vp[1].set(21);
  vp[2].set(31);
  ttree->Fill();

  vp[0].set(12);
  vp[1].set(22);
  vp[2].set(32);
  ttree->Fill();


  ttree->Print();



  Double_t xpx,xpy,xpz; //,xpw;
  ttree->SetBranchAddress("px",&xpx);
  ttree->SetBranchAddress("py",&xpy);
  ttree->SetBranchAddress("pz",&xpz);
  //  ttree->SetBranchAddress("pw",&xpw);
  for (int i=0;i<(int)ttree->GetEntriesFast();i++) 
    {
      ttree->GetEntry(i);
      cout << xpx << " " << xpy << " " << xpz << " " << endl;
    }
/// Schliessen der Datei. -----------------------------------------------------
  mytree->commit();
  mytree->close();
  cout << "Tree Entry: " << xpx << endl;
}

